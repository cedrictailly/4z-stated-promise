//
// 4z-stated-promise v1.2.8
// by CÃ©dric Tailly
// MIT Licence
//

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).StatedPromise=t()}(this,(function(){"use strict";class e{static resolve(e){return new this((t=>t(e)))}static reject(e){return new this(((t,s)=>s(e)))}static coerce(t){if("function"==typeof t)try{t=t()}catch(t){return e.reject(t)}return t instanceof e?t:t instanceof Promise?new e(((e,s)=>{t.then(e,s)})):e.resolve(t)}static allSettled(t){if(!t)return e.resolve([]);const s=function(e){if(e[Symbol.iterator])return e[Symbol.iterator]();if(e.next)return e;throw new TypeError("Value is not iterable")}(t);return new this(((e,t)=>{const r=[],n=(t=null)=>{switch(t?.state){case"fulfilled":r.push({status:"fulfilled",value:t.value});break;case"rejected":r.push({status:"rejected",reason:t.reason})}const{value:i,done:a}=s.next();if(a)return e(r);const o=this.coerce(i);if("pending"!=o.state)return n(o);o.then((e=>{n(o)}),(e=>{n(o)}))};n()}))}static all(t){return t?new this(((e,s)=>{const r=[],n=new Set,i=()=>{0==n.size&&e(r)};for(const e of t){const t=this.coerce(e);switch(t.state){case"fulfilled":r.push(t.value);break;case"rejected":return s(t.reason);default:{const e=r.length;r.push(-1),n.add(t.then((s=>{r[e]=s,n.delete(t),i()}),s))}}}i()})):e.resolve([])}static any(t){return t?new this(((e,s)=>{const r=[],n=new Set,i=()=>{0==n.size&&s(new AggregateError(r,"All promises were rejected"))};for(const s of t){const t=this.coerce(s);switch(t.state){case"fulfilled":return e(t.value);case"rejected":r.push(t.reason);break;default:{const s=r.length;r.push(void 0),n.add(t.then(e,(e=>{r[s]=e,n.delete(t),i()})))}}}i()})):e.reject(new AggregateError([],"No promises to resolve"))}static race(t){return t?new this(((e,s)=>{for(const r of t){const t=this.coerce(r).catch((()=>{}));switch(t.state){case"fulfilled":return e(t.value);case"rejected":return s(t.reason);default:t.then(e).catch(s)}}})):e.reject(new AggregateError([],"No promises to resolve"))}static handle(e){const t=new this(e);switch(t.state){case"fulfilled":return t.value;case"rejected":throw t.reason;default:return t.#e}}#t;#s;#r;#e;get state(){return this.#t}get value(){return this.#s}get reason(){return this.#r}get promise(){return this.#e}constructor(e){if("function"!=typeof e)throw new TypeError("StatedPromise constructor argument must be a function");this.#t="pending",this.#e=new Promise(((t,s)=>{const r=e=>{this.#t="fulfilled",this.#s=e,t(e)},n=e=>{this.#t="rejected",this.#r=e,s(e)};try{e(r,n)}catch(e){n(e)}}))}then(e,t){switch(this.state){case"fulfilled":e(this.value);break;case"rejected":if(!t)throw this.reason;t(this.reason);break;default:this.#e=this.#e.then(e,t)}return this}catch(e){switch(this.state){case"fulfilled":break;case"rejected":e(this.reason);break;default:this.#e=this.#e.catch(e)}return this}finally(e){return this.#e=this.#e.finally(e),this}toJSON(){return{state:this.#t,value:this.#s,reason:this.#r?.toString()}}}return e}));
//# sourceMappingURL=4z-stated-promise.min.js.map
